#-------------------------------------------------------------------------------# WORKING UPDATE TO ARCPRO# ArcPro version: 2.9.2# Python version: 3.7.11# GGLREM version: 3# First release: 08/20/2018# Latest release: 2022## Last modified by: Paula Soto on 03/07/2024# For information on this version please email: paula.soto@dfo-mpo.gc.ca## Name:        GGL REM Toolbox# Purpose: Series of tools to build a Relative Elevation Model (REM)# based on the Geomorphic Grade Line (GGL).# Author:      Matt Helstab## Copyright:   (c) jmhelstab 2018# Licence:     GNU General Public License v3.0#-------------------------------------------------------------------------------#Import Modulesimport arcpyimport osimport sysfrom arcpy.sa import *import numpy#Define Toolboxsclass Toolbox(object):    def __init__(self):        """Define the toolbox (the name of the toolbox is the name of the        .pyt file)."""        self.label = "GGL REM Toolbox"        self.alias = "GGLREM"        # List of tool classes associated with this toolbox        self.tools = [Centerline, CrossSections, CenterlineStations, REM]#Create Centerline Feature Class Tool Parametersclass Centerline(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "1. Create a Centerline Feature Class"        self.description = "Create a polyline Feature Class in the current workspace with expected Fields and Data Types for the Create Cross Section Tool"        self.canRunInBackground = False    def getParameterInfo(self):        # Define descriptions for parameters        workspaceLOC_desc = "The directory where the output feature class will be created."        geodatabaseLOC_desc = "The geodatabase where the output feature class will be created."        centerCOORD_desc = "The coordinate system to match the LiDAR DEM."        nameFC_desc = "The name of the output centerline feature class."        workspaceLOC = arcpy.Parameter(            displayName = "Input Workspace Location",            name = "WorkspaceLocation",            datatype = "DEWorkspace",            parameterType = "Required",            direction = "Input")        workspaceLOC.filter.list = ["File System"]        geodatabaseLOC = arcpy.Parameter(            displayName = "Input Project Geodatabase",            name = "geoLocation",            datatype = "DEWorkspace",            parameterType = "Required",            direction = "Input")        geodatabaseLOC.filter.list = ["Local Database", "Remote Database"]        centerCOORD = arcpy.Parameter(            displayName = "Match Coordinate System to LiDAR DEM",            name = "CoordinateSystem",            datatype = "GPSpatialReference",            parameterType = "Required",            direction = "Input")        nameFC = arcpy.Parameter(            displayName = "Input Centerline Feature Class Name",            name = "CenterlineName",            datatype = "GPString",            parameterType = "Required",            direction = "Output")        params = [workspaceLOC, geodatabaseLOC, centerCOORD, nameFC]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        #Set Local Variables        ws = parameters[0].valueAsText        gdb = parameters[1].valueAsText        dem = parameters[2].valueAsText        name_fc = parameters[3].valueAsText        cl_name = "Centerline_" + name_fc                aprx = arcpy.mp.ArcGISProject("CURRENT")        #Choose whatever map is open        for map in aprx.listMaps():            # Check if the map is active            if map == aprx.activeMap:                # Use the active map                aprxMap = map                break        #Create Feature Class        arcpy.AddMessage("Creating Feature Class")        arcpy.CreateFeatureclass_management(gdb, cl_name, "POLYLINE", "", "", "", dem)        #Add Route ID Field to Feature Class        arcpy.AddMessage("Adding Route ID Field")        #arcpy.AddField_management(cl_name, "ROUTEID", "TEXT") ## OLD SCRIPT        arcpy.AddField_management(os.path.join(gdb, cl_name), "ROUTEID", "TEXT")                #Add Layers        arcpy.AddMessage("Adding Centerline Layer")        fc_cl_path = os.path.join(gdb, cl_name)        arcpy.AddMessage(fc_cl_path)        aprxMap.addDataFromPath(fc_cl_path)        return#Create Cross Section Tool Parametersclass CrossSections(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "2. Create Cross Sections and Routed Centerline"        self.description = "Creates cross section polylines and routed valley centerline."        self.canRunInBackground = False    def getParameterInfo(self):        #First parameter [0]        inFC = arcpy.Parameter(            displayName = "Input Centerline Feature Class",            name = "InputCenterline",            datatype = ["GPFeatureLayer", "DEFeatureClass", "DEShapefile"],            parameterType = "Required",            direction = "Input")        #Third parameter [1]        routeID = arcpy.Parameter(            displayName = "Select Centerline Route ID",            name = "RouteID",            datatype = "GPString",            parameterType = "Required",            direction = "Input")        routeID.filter.type = "ValueList"        routeID.filter.list = []        #Forth parameter [2]        offCenter = arcpy.Parameter(            displayName = "Input Offset Distance From Centerline (m)",            name = "OffsetLeft",            datatype = "GPLong",            parameterType = "Required",            direction = "Input")        #Sixth parameter [3]        drawDirection = arcpy.Parameter(            displayName = "Select Direction to Start Stationing From",            name = "DrawDirection",            datatype = "GPString",            parameterType = "Required",            direction = "Input")        drawDirection.filter.type = "ValueList"        drawDirection.filter.list = ["UPPER_LEFT", "UPPER_RIGHT", "LOWER_LEFT", "LOWER_RIGHT"]        params = [inFC, routeID, offCenter, drawDirection]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        """Modify the values and properties of parameters before internal        validation is performed.  This method is called whenever a parameter        has been changed."""        if parameters[0].value:            with arcpy.da.SearchCursor(parameters[0].valueAsText, 'ROUTEID') as rows:                parameters[1].filter.list = sorted(list(set([row[0] for row in rows])))        else:            parameters[1].filter.list = []        return    def updateMessages(self, parameters):        if parameters[2].altered:            if parameters[2].value <= 0:                parameters[2].setErrorMessage('''Offset Value must be greater than zero.''')        return    def execute(self, parameters, messages):        #Get Parameter Inputs        fc_in = parameters[0].valueAsText        route_id = parameters[1].valueAsText        route_field = "ROUTEID"        o_left = parameters[2].valueAsText        o_right = parameters[2].valueAsText        draw_dir = parameters[3].valueAsText        fc_routed = "Routed_" + route_id        off_table = "Offset_Table_" + route_id        desc = arcpy.Describe(fc_in)        gdb = desc.path        routed_w_gdb = os.path.join(gdb, fc_routed)        off_table_w_gdb = os.path.join(gdb, off_table)        merged = "Merged_" + route_id        merged_gdb = os.path.join(gdb, merged)        x_sec = "CrossSections_" + route_id        x_sec_gdb = os.path.join(gdb, x_sec)        #Set Workspace Environment and Map Properties        aprx = arcpy.mp.ArcGISProject("CURRENT")        for map in aprx.listMaps():            # Check if the map is active            if map == aprx.activeMap:                # Use the active map                aprxMap = map                break        arcpy.env.overwriteOutput = True        # Process: Create Routes        arcpy.AddMessage("Creating Routes")        arcpy.CreateRoutes_lr(fc_in, route_field, routed_w_gdb, "LENGTH", "", "", draw_dir, "", "", "IGNORE", "INDEX")        #Create Table        arcpy.AddMessage("Building Offset Table")        arcpy.CreateTable_management(gdb, off_table)        #Add Fields        arcpy.AddField_management(off_table_w_gdb, "LOCATION", "LONG")        arcpy.AddField_management(off_table_w_gdb, "OFFSET_LEFT", "LONG")        arcpy.AddField_management(off_table_w_gdb, "OFFSET_RIGHT", "LONG")        arcpy.AddField_management(off_table_w_gdb, route_field, "TEXT")        #Extract values from Centerline Polyline and create variable with desired row length        arcpy.AddMessage("Extracting Values")        fields_centerline = ['shape_length', 'shape_Length', 'shape_LENGTH', 'Shape_length', 'Shape_Length', 'Shape_LENGTH', 'SHAPE_length', 'SHAPE_Length', 'SHAPE_LENGTH',]        LOCATION1 = arcpy.da.SearchCursor(routed_w_gdb, fields_centerline,).next()[0]        LENGTH = int(LOCATION1)        LOCATION2 = range(1,LENGTH)        NAME =  arcpy.da.SearchCursor(fc_in, route_field,)        NAME = [NAME] * LENGTH        #Append Extracted Values to Offset_Table        arcpy.AddMessage("Populating Offset Table")        fields = ["LOCATION", "OFFSET_LEFT", "OFFSET_RIGHT", route_field]        cursor = arcpy.da.InsertCursor(off_table_w_gdb, fields)        for x in range(1, LENGTH):            cursor.insertRow((x, o_left, o_right, route_id, ))        del(cursor)        #Process: Make Route Event Layers Left and Right        arcpy.AddMessage("Creating Offset Stations")        arcpy.MakeRouteEventLayer_lr(routed_w_gdb,"ROUTEID",off_table_w_gdb,"ROUTEID POINT LOCATION", "leftoff", "OFFSET_LEFT","NO_ERROR_FIELD","NO_ANGLE_FIELD","NORMAL","ANGLE","LEFT","POINT")        arcpy.MakeRouteEventLayer_lr(routed_w_gdb,"ROUTEID",off_table_w_gdb,"ROUTEID POINT LOCATION", "rightoff", "OFFSET_RIGHT","NO_ERROR_FIELD","NO_ANGLE_FIELD","NORMAL","ANGLE","RIGHT","POINT")        #Merge Offset Event Layers        arcpy.AddMessage("Merging Offsets")        arcpy.Merge_management(["leftoff","rightoff"], merged_gdb, "")        #Convert Points to Lines        arcpy.AddMessage("Converting Offset Points to Cross Sections")        arcpy.PointsToLine_management(merged_gdb, x_sec_gdb, "LOCATION", "LOCATION")        #Add Layers        fc_routed_path = os.path.join(gdb, fc_routed)        aprxMap.addDataFromPath(fc_routed_path)        aprxMap.addDataFromPath(x_sec_gdb)        #Delete Temporary Features        arcpy.Delete_management(os.path.join(gdb, "merged_gdb"))        arcpy.Delete_management(os.path.join(gdb, "leftoff"))        arcpy.Delete_management(os.path.join(gdb, "rightoff"))        return# Create Centerline Stations Tool Parametersclass CenterlineStations(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "3. Create GGL Table and Centerline Stations"        self.description = "Creates a Point Feature Class at each intersection of the Centerline and Cross Section polylines, and then appends elevation data to each point."        self.canRunInBackground = False    def getParameterInfo(self):        #First parameter        inFC1 = arcpy.Parameter(            displayName = "Input Routed Centerline Feature Class",            name = "InputCenterlineRouted",            datatype = ["GPFeatureLayer", "DEFeatureClass"],            parameterType = "Required",            direction = "Input")        #Second parameter        routeID = arcpy.Parameter(            displayName = "Select Centerline Route ID",            name = "RouteID",            datatype = "GPString",            parameterType = "Required",            direction = "Input")        routeID.filter.type = "ValueList"        routeID.filter.list = []        #Third parameter        inFC2 = arcpy.Parameter(            displayName = "Input Cross Section Feature Class",            name = "InputCrossSection",            datatype = ["GPFeatureLayer", "DEFeatureClass"],            parameterType = "Required",            direction = "Input")        bufferBOOLEAN = arcpy.Parameter(            displayName = "Include Centerline Buffer Distance?",            name = "bufferBoolean",            datatype = "GPString",            parameterType = "Required",            direction = "Input")        bufferBOOLEAN.filter.type = "ValueList"        bufferBOOLEAN.filter.list = ["Yes", "No"]        #Fourth parameter        buffer = arcpy.Parameter(            displayName = "Input Centerline Buffer Distance",            name = "buffer",            datatype = "GPLong",            parameterType = "Optional",            direction = "Input")        buffer.value = "1"        #Fifth parameter        inRASTER = arcpy.Parameter(            displayName = "Input LiDAR Digital Elevation Model",            name = "InputLidar",            datatype = ["GPRasterLayer", "GPLayer", "DEMosaicDataset", "GPMosaicLayer", "DERasterDataset", "GPRasterDataLayer"],            parameterType = "Required",            direction = "Input")        params = [inFC1, routeID, inFC2, bufferBOOLEAN, buffer, inRASTER]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        if parameters[0].value:            with arcpy.da.SearchCursor(parameters[0].valueAsText, "ROUTEID") as rows:                parameters[1].filter.list = [row[0] for row in rows]        else:            parameters[1].filter.list = []        if parameters[3].value == "Yes":            parameters[4].enabled = True            parameters[4].parameterType = "Required"        else:            parameters[4].enabled = False            parameters[4].parameterType = "Disabled"            parameters[4].value = "1"        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        if parameters[4].altered:            if parameters[4].value <= 0:                parameters[4].setErrorMessage('''Buffer Value must be an integer greater than zero.''')        return    def execute(self, parameters, messages):        #Set Local Variables        centerroute = parameters[0].valueAsText        routeid = parameters[1].valueAsText        crosssection = parameters[2].valueAsText        bufferboolean = parameters[3].valueAsText        buffer = parameters[4].valueAsText        raster = parameters[5].valueAsText        desc = arcpy.Describe(centerroute)        gdb = desc.path        dir = os.path.dirname(gdb)        stations = "Stations_" + routeid        yes_clip_crosssection = os.path.join(gdb, crosssection + "_clipped_buffered")        clipped_XSec = crosssection + "_CLIP"        clipped_w_gdb = os.path.join(gdb, clipped_XSec)        out_table = os.path.join(dir, "GGL_Table_" + routeid + ".csv")        #Set Workspace Environment and Map Properties        aprx = arcpy.mp.ArcGISProject("CURRENT")        #Use active "map" in arcgis pro        for map in aprx.listMaps():            # Check if the map is active            if map == aprx.activeMap:                # Use the active map                aprxMap = map                break        # Check if the DEM exists because if it does it will need to be deleted, otherwise it will throw an error.        if os.path.exists("DEM_integer"):            # If it exists, delete it            os.remove("DEM_integer")            print("DEM deleted successfully.")        else:            # If it doesn't exist, print a message            print("DEM not found.")        # Turn DEM into integer point rather than floating point so that it can be converted to a polygon        raster_obj = arcpy.Raster(raster)        DEM_integer = os.path.join(gdb, "DEM_integer")        Raster_Calculator = DEM_integer        DEM_integer = arcpy.ia.Int(raster_obj)        DEM_integer.save(Raster_Calculator)        # Process: Raster to Polygon (Raster to Polygon) (conversion) -        DEM_Shapefile = os.path.join(gdb, "DEM_Shapefile")        with arcpy.EnvManager(outputMFlag="Disabled", outputZFlag="Disabled"):            arcpy.conversion.RasterToPolygon(in_raster=DEM_integer, out_polygon_features=DEM_Shapefile,                                             simplify="SIMPLIFY", raster_field="Value",                                             create_multipart_features="SINGLE_OUTER_PART",                                             max_vertices_per_feature=None)        # Process: Clip (Clip) (analysis)        arcpy.analysis.Clip(in_features=crosssection, clip_features=DEM_Shapefile,                            out_feature_class=clipped_w_gdb, cluster_tolerance="")        aprxMap.addDataFromPath(clipped_w_gdb)        inFeatures = [os.path.join(gdb, centerroute), clipped_w_gdb]        fc_stations_path = os.path.join(gdb, stations)        #aprxMap.addDataFromPath(fc_stations_path)        # start bufferboolean -----------------------------------------------------------------------------        arcpy.AddMessage("Intersecting Centerline and Cross Section Polylines...")        arcpy.Intersect_analysis(inFeatures, os.path.join(gdb, "xsec"), "", "", "POINT")        # separate features        arcpy.MultipartToSinglepart_management(os.path.join(gdb, "xsec"), os.path.join(gdb, "xsec2"))        # Extract elevation data from DEM to Centerline Station Points        arcpy.AddMessage("Extracting Elevation Values...")        arcpy.sa.ExtractValuesToPoints(os.path.join(gdb, "xsec2"), raster, fc_stations_path, "INTERPOLATE")        if "No" in bufferboolean:            arcpy.AddMessage("No Offset Buffer")            px = [row[0] for row in arcpy.da.SearchCursor(fc_stations_path, "LOCATION")]            py = [row[0] for row in arcpy.da.SearchCursor(fc_stations_path, "RASTERVALU")]        else:            #Creating Centerling Stations Point Feature Class            arcpy.AddMessage("Offset Buffer Entered")            #Buffer Centerline            arcpy.AddMessage("Evaluating Buffer Distance...")            arcpy.Buffer_analysis(centerroute, os.path.join(gdb, "center_buff"), buffer, "FULL", "FLAT", "ALL", "", "")            #Clip Cross Sections to Centerline Buffer            arcpy.AddMessage("Clipping Buffer Distance...")            arcpy.Clip_analysis(clipped_w_gdb, os.path.join(gdb, "center_buff"), yes_clip_crosssection, "")            #Convert Clipped Cross Sections to Raster            arcpy.AddMessage("Converting things...")            arcpy.PolylineToRaster_conversion(yes_clip_crosssection, "LOCATION", os.path.join(gdb, "clip_xsec_raster"), "", "LOCATION", "1")            # Get the extent of the mask raster            desc_raster = arcpy.Describe(raster)            extent = desc_raster.extent            # Define the extent to be only inside the raster            extent_inside_raster = f"{extent.XMin} {extent.YMin} {extent.XMax} {extent.YMin}"            extract_clip_1 = os.path.join(gdb, "Extract_clip1")            Extract_by_mask = extract_clip_1            # Perform the Extract by Mask operation with dynamic extent            with arcpy.EnvManager(cellSize="MINOF", extent=extent_inside_raster, mask=raster, snapRaster=raster):                # Perform Extract by Mask operation                Extract_clip1 = arcpy.sa.ExtractByMask(in_raster=os.path.join(gdb, "clip_xsec_raster"),                                                      in_mask_data=raster)                Extract_clip1.save(Extract_by_mask)            #Convert Clipped Cross Section Raster to Points            arcpy.RasterToPoint_conversion(Extract_by_mask, os.path.join(gdb, "xsec_clipped_points"), "VALUE")            #Extract elevation data from DEM to Clipped Cross Section Station Points            arcpy.sa.ExtractValuesToPoints( os.path.join(gdb, "xsec_clipped_points"), raster, os.path.join(gdb,  "xsec_stations"), "INTERPOLATE")            #Delete Unneeded Feature Classes            # arcpy.Delete_management(os.path.join(gdb,"xsec"))            # arcpy.Delete_management(os.path.join(gdb,"xsec2"))            # arcpy.Delete_management(os.path.join(gdb,"center_buff"))            # arcpy.Delete_management(os.path.join(gdb,"clip_xsec_raster"))            # arcpy.Delete_management(os.path.join(gdb,"xsec_clipped_points"))            #arcpy.Delete_management(os.path.join(gdb, "xsec_stations"))            arcpy.AddMessage("Building GGL...")            px = [row[0] for row in arcpy.da.SearchCursor(os.path.join(gdb, "xsec_stations"), "grid_code")]            py = [row[0] for row in arcpy.da.SearchCursor(os.path.join(gdb, "xsec_stations"), "RASTERVALU")]        p_2 = numpy.power(px, 2)        p_3 = numpy.power(px, 3)        p_4 = numpy.power(px, 4)        p_5 = numpy.power(px, 5)        arcpy.AddMessage("Starting px, pyx filtering for 'none'")        # Find indices where px or py is None        none_indices = [i for i, (x, y) in enumerate(zip(px, py)) if x is None or y is None]        # Filter px and py to remove None values        px_py_filtered = [(x, y) for x, y in zip(px, py) if x is not None and y is not None]        px_filtered, py_filtered = zip(*px_py_filtered)        if len(px_filtered) > 1:  # Ensure there are enough points            arcpy.AddMessage("LINEAR")            polyfit_1 = numpy.polyfit(px_filtered, py_filtered, 1)            p1 = numpy.polyval(polyfit_1, px_filtered)            arcpy.AddMessage("QUADRATIC")            polyfit_2 = numpy.polyfit(px_filtered, py_filtered, 2)            p2 = numpy.polyval(polyfit_2, px_filtered)            # Third Order            arcpy.AddMessage("THIRD ORDER POLY")            polyfit_3 = numpy.polyfit(px_filtered, py_filtered, 3)            p3 = numpy.polyval(polyfit_3, px_filtered)            # Fourth Order            arcpy.AddMessage("FOURTH ORDER POLY")            polyfit_4 = numpy.polyfit(px_filtered, py_filtered, 4)            p4 = numpy.polyval(polyfit_4, px_filtered)            # Fifth Order            arcpy.AddMessage("FIFTH ORDER POLY")            polyfit_5 = numpy.polyfit(px_filtered, py_filtered, 5)            p5 = numpy.polyval(polyfit_5, px_filtered)        else:            print("Error: Insufficient data for polyfit.")        # Build Structured Array        ##Set Data Types        arcpy.AddMessage("Almost Done...")        dt = {'names': ['LOCATION', 'LIDAR', 'LINEAR', 'POLY2', 'POLY3', 'POLY4', 'POLY5'],              'formats': [int, numpy.float32, numpy.float32, numpy.float32, numpy.float32, numpy.float32,                          numpy.float32]}        ##Build Blank Structured Array        poly = numpy.zeros(len(px_filtered), dtype=dt)        ##Add values to Structured Array        poly['LOCATION'] = px_filtered        poly['LIDAR'] = py_filtered        poly['LINEAR'] = p1        poly['POLY2'] = p2        poly['POLY3'] = p3        poly['POLY4'] = p4        poly['POLY5'] = p5        sorted_poly = numpy.sort(poly, order="LOCATION")        # Convert Structured Array to Table        arcpy.da.NumPyArrayToTable(sorted_poly, out_table)        # Create a .cvs table for model evaluation in R Studio        fm_fields = ["LOCATION", "LIDAR", "LINEAR", "POLY2", "POLY3", "POLY4", "POLY5"]        # Join Model Output to Cross Sections and Centerline Stations Feature Classes        arcpy.AddMessage("Joining Modeled Values to Features")        arcpy.JoinField_management(fc_stations_path, "LOCATION", out_table, "LOCATION",                                   ["LIDAR", "LINEAR", "POLY2", "POLY3", "POLY4", "POLY5"])        arcpy.JoinField_management(clipped_w_gdb, "LOCATION", out_table, "LOCATION",                                   ["LIDAR", "LINEAR", "POLY2", "POLY3", "POLY4", "POLY5"])        returnclass REM(object):    def __init__(self):        """Define the tool (tool name is the name of the class)."""        self.label = "4. Create Relative Elevation Model(s)"        self.description = "Joins modeled GGL elevations to cross sections, converts cross sections to a raster, and lastly subtracts cross section raster from LiDAR raster to produce the REM."        self.canRunInBackground = False    def getParameterInfo(self):        #First parameter        inNAME = arcpy.Parameter(            displayName = "Input Unique GGLREM Name",            name = "GGLREMname",            datatype = ["GPString"],            parameterType = "Required",            direction = "Input")        #Second parameter        inFC = arcpy.Parameter(            displayName = "Input Cross Section Feature Class",            name = "InputCrossSections",            datatype = ["GPFeatureLayer", "DEFeatureClass"],            parameterType = "Required",            direction = "Input")        #Third parameter        gglLIST = arcpy.Parameter(            displayName = "Select Values/Model to Construct Relative Eleavtion Model",            name = "GglList",            datatype = "GPString",            parameterType = "Required",            direction = "Input",            multiValue = "True")        gglLIST.filter.type = "ValueList"        gglLIST.filter.list = ["Custom", "Linear Model", "Polynomial 2nd", "Polynomial 3rd", "Polynomial 4th", "Polynomial 5th"]        #Fourth parameter        gglCUST = arcpy.Parameter(            displayName = "Input Custom GGL Table [ONLY IF RUNNING CUSTOM MODEL]",            name = "CustomGglTable",            datatype = "DETable",            parameterType = "Optional",            direction = "Input")        #Fifth parameter        gglFIELD = arcpy.Parameter(            displayName = "Select Field with GGL Values for Detrending",            name = "CustomGglField",            datatype = "Field",            parameterType = "Optional",            direction = "Input")        gglFIELD.filter.list =[]        gglFIELD.parameterDependencies = [gglCUST.name]        #Sixth parameter        inDEM = arcpy.Parameter(            displayName = "Input LiDAR DEM",            name = "InputLidar",            datatype = ["GPRasterLayer","DERasterDataset", "DERasterCatalog"],            parameterType = "Required",            direction = "Input")        #Seventh parameter        outREM = arcpy.Parameter(            displayName = "Output Relative Elevation Model(s)",            name = "OutputREM",            datatype = "GPString",            parameterType = "Optional",            direction = "Input",            multiValue = "True")        outREM.filter.type = "ValueList"        outREM.filter.list = ["Integer_Decimeters", "Integer_Feet", "Float_Feet"]        params = [inNAME, inFC, gglLIST, gglCUST, gglFIELD, inDEM, outREM]        return params    def isLicensed(self):        """Set whether tool is licensed to execute."""        return True    def updateParameters(self, parameters):        if parameters[3].value:            parameters[4].enabled = True        else:            parameters[4].enabled = False        return    def updateMessages(self, parameters):        """Modify the messages created by internal validation for each tool        parameter.  This method is called after internal validation."""        return    def execute(self, parameters, messages):        #Set local variables        gglrem_name = parameters[0].valueAsText        crosssections = parameters[1].valueAsText        detrend = parameters[2].valueAsText        ggl_table = parameters[3].valueAsText        ggl_field = parameters[4].valueAsText        lidar = parameters[5].valueAsText        rems = parameters[6].valueAsText        desc = arcpy.Describe(crosssections)        gdb = desc.path        #Set Workspace Environment and Map Properties        aprx = arcpy.mp.ArcGISProject("CURRENT")        #Use active "map" in arcgis pro        for map in aprx.listMaps():            # Check if the map is active            if map == aprx.activeMap:                # Use the active map                aprxMap = map                break        # Set up variable names and paths according to settings selected in tool        if "Custom" in detrend:                arcpy.AddMessage(" Custom GGLREM")                arcpy.AddMessage("Copy Rows Management")                arcpy.CopyRows_management(ggl_table, os.path.join(gdb,"ggl_table_custom"))                arcpy.AddMessage("Join Field Management")                arcpy.JoinField_management(crosssections, "LOCATION", "ggl_table_custom", "LOCATION", ggl_field)                value_field = ggl_field                out_rasterdataset = os.path.join(gdb, "Custom")                final_raster_float = os.path.join(gdb, gglrem_name + "_Custom_Float_m")        elif "Linear Model" in detrend:            arcpy.AddMessage("Linear")            value_field = "LINEAR"            final_raster_float = os.path.join(gdb, gglrem_name + "_Linear_Float_m")        elif "Polynomial 2nd" in detrend:            value_field = "POLY2"            final_raster_float = os.path.join(gdb, gglrem_name + "_Poly2_Float_m")        elif "Polynomial 3rd" in detrend:            value_field = "POLY3"            final_raster_float = os.path.join(gdb, gglrem_name + "_Poly3_Float_m")        elif "Polynomial 4th" in detrend:            value_field = "POLY4"            final_raster_float = os.path.join(gdb, gglrem_name + "_Poly4_Float_m")        else: #5th polynomial            value_field = "POLY5"            final_raster_float = os.path.join(gdb, gglrem_name + "_Poly5_Float_m")        #out raster data set name        out_rasterdataset = os.path.join(gdb, value_field)        if "Integer_Decimeters" in rems:            measurement_factor = 10            msmt_name_path = os.path.join(gdb, gglrem_name + "_" + value_field + "_Int_DeciM")        elif "Integer_Feet" in rems:            measurement_factor = 3.28084            msmt_name_path = os.path.join(gdb, gglrem_name + "_" + value_field + "_Int_Ft")        else: #float feet            measurement_factor = 3.28084            msmt_name_path = os.path.join(gdb, gglrem_name + "_" + value_field + "_Flt_Ft")        # Actually run DEM production -------------------------------        arcpy.AddMessage("Building GGLREM")        arcpy.PolylineToRaster_conversion(crosssections, value_field, out_rasterdataset, "", "", "1")        arcpy.AddMessage("Minus 3D")        arcpy.Minus_3d(lidar, out_rasterdataset, final_raster_float)        # Add unit        arcpy.AddMessage("Unit")        if "Integer_Feet" in rems or "Integer_Decimeters" in rems:            DEM_unit = Int(Raster(final_raster_float) * measurement_factor)        else:            DEM_unit = Raster(final_raster_float) * measurement_factor        DEM_unit.save(msmt_name_path)        aprxMap.addDataFromPath(msmt_name_path)        arcpy.AddMessage(msmt_name_path)        arcpy.AddMessage("Finished creating DEM")        #Delete Unneeded Feature Classes        arcpy.Delete_management(out_rasterdataset)        arcpy.AddMessage("KEEP ASKING QUESTIONS!")        return   